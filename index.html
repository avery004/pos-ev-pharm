<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Pharma Market Share EV Explorer</title>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Space+Grotesk:wght@400;500;600;700&display=swap" rel="stylesheet">
  <style>
    :root {
      --ink: #0f172a;
      --muted: #5c6b8a;
      --panel: rgba(255, 255, 255, 0.08);
      --accent: #0ea5e9;
      --accent-2: #a855f7;
      --bg: radial-gradient(circle at 20% 20%, rgba(14,165,233,0.2), transparent 35%),
             radial-gradient(circle at 80% 0%, rgba(168,85,247,0.2), transparent 30%),
             #0b1220;
      --card: rgba(255,255,255,0.06);
    }
    * {
      box-sizing: border-box;
    }
    body {
      margin: 0;
      font-family: 'Space Grotesk', 'Helvetica Neue', sans-serif;
      background: var(--bg);
      color: #e5e7eb;
      min-height: 100vh;
    }
    a { color: var(--accent); }
    .page {
      max-width: 1100px;
      margin: 0 auto;
      padding: 32px 20px 60px;
    }
    .hero {
      background: linear-gradient(135deg, rgba(14,165,233,0.14), rgba(168,85,247,0.16));
      border: 1px solid rgba(255,255,255,0.08);
      border-radius: 20px;
      padding: 28px;
      backdrop-filter: blur(8px);
      box-shadow: 0 14px 50px rgba(0,0,0,0.28);
    }
    .hero h1 {
      margin: 0 0 10px;
      font-size: 32px;
      letter-spacing: -0.02em;
    }
    .hero p {
      margin: 0;
      color: var(--muted);
      line-height: 1.5;
    }
    .grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(260px, 1fr));
      gap: 16px;
      margin-top: 20px;
    }
    .card {
      background: var(--card);
      border: 1px solid rgba(255,255,255,0.08);
      border-radius: 16px;
      padding: 18px;
      box-shadow: 0 8px 30px rgba(0,0,0,0.2);
    }
    .card h3 {
      margin: 0 0 12px;
      font-size: 18px;
      color: #f8fafc;
      display: flex;
      align-items: center;
      justify-content: space-between;
    }
    label {
      display: block;
      margin: 12px 0 6px;
      font-size: 13px;
      color: var(--muted);
    }
    input[type="number"],
    input[type="date"] {
      width: 100%;
      padding: 10px 12px;
      border-radius: 10px;
      border: 1px solid rgba(255,255,255,0.08);
      background: rgba(255,255,255,0.04);
      color: #f8fafc;
      font-size: 14px;
      transition: border-color 0.2s, background 0.2s;
    }
    input:focus {
      outline: none;
      border-color: var(--accent);
      background: rgba(255,255,255,0.06);
      box-shadow: 0 0 0 3px rgba(14,165,233,0.15);
    }
    .actions {
      display: flex;
      align-items: center;
      gap: 12px;
      margin: 26px 0 18px;
      flex-wrap: wrap;
    }
    button {
      padding: 12px 18px;
      border-radius: 12px;
      border: 1px solid rgba(255,255,255,0.12);
      background: linear-gradient(120deg, var(--accent), var(--accent-2));
      color: #0b1220;
      font-weight: 700;
      font-size: 14px;
      cursor: pointer;
      box-shadow: 0 10px 25px rgba(14,165,233,0.25);
      transition: transform 0.15s ease, box-shadow 0.15s ease;
    }
    button:hover { transform: translateY(-1px); box-shadow: 0 14px 28px rgba(14,165,233,0.35); }
    button:active { transform: translateY(0); }
    .status {
      font-size: 13px;
      color: var(--muted);
    }
    .ev-card {
      background: var(--card);
      border: 1px solid rgba(255,255,255,0.08);
      border-radius: 14px;
      padding: 16px 18px;
      margin-bottom: 14px;
      display: flex;
      flex-direction: column;
      gap: 4px;
    }
    .ev-value {
      font-size: 26px;
      font-weight: 700;
      color: #f8fafc;
    }
    .ev-note { color: var(--muted); font-size: 13px; }
    .scenario-list {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(240px, 1fr));
      gap: 12px;
      margin-top: 10px;
    }
    .scenario-card {
      border: 1px solid rgba(255,255,255,0.08);
      border-radius: 12px;
      padding: 12px 14px;
      background: rgba(255,255,255,0.03);
    }
    .scenario-card h4 {
      margin: 0 0 4px;
      font-size: 15px;
      color: #f8fafc;
    }
    .scenario-card .meta {
      color: var(--muted);
      font-size: 13px;
    }
    .plot-area {
      margin-top: 22px;
      background: var(--card);
      border-radius: 14px;
      border: 1px solid rgba(255,255,255,0.08);
      padding: 12px;
    }
    .plot-area h3 {
      margin: 0 0 10px;
      font-size: 16px;
      color: #f8fafc;
    }
    #plot {
      width: 100%;
      display: block;
      border-radius: 10px;
      border: 1px solid rgba(255,255,255,0.06);
      background: rgba(255,255,255,0.05);
      min-height: 260px;
    }
    .tooltip {
      position: fixed;
      background: rgba(10,14,26,0.9);
      border: 1px solid rgba(255,255,255,0.12);
      color: #f8fafc;
      padding: 8px 10px;
      border-radius: 10px;
      font-size: 12px;
      pointer-events: none;
      box-shadow: 0 6px 24px rgba(0,0,0,0.35);
      opacity: 0;
      transition: opacity 0.1s ease;
      z-index: 20;
      max-width: 220px;
      backdrop-filter: blur(6px);
    }
    .pill {
      display: inline-block;
      padding: 4px 8px;
      border-radius: 999px;
      font-size: 12px;
      font-weight: 600;
      color: #0b1220;
    }
    .pill.a { background: #5f4b8b; color: #f8fafc; }
    .pill.b { background: #3c9d9b; color: #041620; }
    .pill.c { background: #e67300; color: #0b1220; }
    @media (max-width: 720px) {
      .hero h1 { font-size: 26px; }
      .ev-value { font-size: 22px; }
    }
  </style>
</head>
<body>
  <div class="page">
    <section class="hero">
      <h1>Market Share EV with WebR</h1>
      <p>Model three candidate drugs, each with a success probability, release date, and patent expiry. We assume successful entrants share market value equally while overlapping, and all branded share stops at the first successful patent expiry.</p>
    </section>

    <div class="grid" id="companyInputs">
      <div class="card" data-company="A">
        <h3>Company A <span class="pill a">A</span></h3>
        <label for="prob-A">Success probability (0-1)</label>
        <input id="prob-A" name="prob-A" type="number" min="0" max="1" step="0.01" value="0.7" data-field="prob">
        <label for="conf-A">Confidence</label>
        <select id="conf-A" name="conf-A" data-field="confidence" data-company="A">
          <option value="high">High (0.01)</option>
          <option value="medium">Medium (0.05)</option>
          <option value="low">Low (0.20)</option>
        </select>
        <label for="rel-A">Release date</label>
        <input id="rel-A" name="rel-A" type="date" value="2026-06-01" data-field="release">
        <label for="exp-A">Patent expiry</label>
        <input id="exp-A" name="exp-A" type="date" value="2036-06-01" data-field="expiry">
      </div>
      <div class="card" data-company="B">
        <h3>Company B <span class="pill b">B</span></h3>
        <label for="prob-B">Success probability (0-1)</label>
        <input id="prob-B" name="prob-B" type="number" min="0" max="1" step="0.01" value="0.55" data-field="prob">
        <label for="conf-B">Confidence</label>
        <select id="conf-B" name="conf-B" data-field="confidence" data-company="B">
          <option value="high">High (0.01)</option>
          <option value="medium" selected>Medium (0.05)</option>
          <option value="low">Low (0.20)</option>
        </select>
        <label for="rel-B">Release date</label>
        <input id="rel-B" name="rel-B" type="date" value="2027-01-15" data-field="release">
        <label for="exp-B">Patent expiry</label>
        <input id="exp-B" name="exp-B" type="date" value="2034-12-31" data-field="expiry">
      </div>
      <div class="card" data-company="C">
        <h3>Company C <span class="pill c">C</span></h3>
        <label for="prob-C">Success probability (0-1)</label>
        <input id="prob-C" name="prob-C" type="number" min="0" max="1" step="0.01" value="0.45" data-field="prob">
        <label for="conf-C">Confidence</label>
        <select id="conf-C" name="conf-C" data-field="confidence" data-company="C">
          <option value="high">High (0.01)</option>
          <option value="medium">Medium (0.05)</option>
          <option value="low" selected>Low (0.20)</option>
        </select>
        <label for="rel-C">Release date</label>
        <input id="rel-C" name="rel-C" type="date" value="2025-10-01" data-field="release">
        <label for="exp-C">Patent expiry</label>
        <input id="exp-C" name="exp-C" type="date" value="2033-05-20" data-field="expiry">
      </div>
    </div>

    <div class="actions">
      <button id="run">Compute EV &amp; Scenarios</button>
      <button id="download" disabled>Download ZIP</button>
      <span class="status" id="status">WebR loading…</span>
    </div>

    <div class="ev-card">
      <div class="ev-value" id="evValue">—</div>
      <div class="ev-note">Expected market share for Company A as a percent of its maximum possible share-days (A succeeds alone from its release to its expiry).</div>
    </div>

    <div class="scenario-list" id="scenarioList"></div>

    <div class="plot-area">
      <h3>All market share timelines</h3>
      <canvas id="plot" aria-label="Scenario plot generated in R via WebR"></canvas>
    </div>
  </div>
  <div id="plotTooltip" class="tooltip"></div>

  <script type="module">
    import { WebR } from "https://webr.r-wasm.org/latest/webr.mjs";
    import JSZip from "https://cdn.jsdelivr.net/npm/jszip@3.10.1/+esm";

    const statusEl = document.getElementById('status');
    const evEl = document.getElementById('evValue');
    const scenarioList = document.getElementById('scenarioList');
    const plotEl = document.getElementById('plot');
    const runBtn = document.getElementById('run');
    const downloadBtn = document.getElementById('download');
    const tooltip = document.getElementById('plotTooltip');

    let webRReady = false;
    runBtn.disabled = true;
    let plotState = null;
    let lastResults = null;
    let lastInputs = null;

    // Explicit baseUrl avoids 404s if the module path is rebased by the dev server.
    const webR = new WebR({ baseUrl: "https://webr.r-wasm.org/latest/" });
    // Shelter is available, but we can use direct helpers for simplicity.

    const setStatus = (msg) => statusEl.textContent = msg;

    const bootstrapR = `
      calc_scenario <- function(success_vec, p, release, expiry) {
        prob <- prod(ifelse(success_vec == 1, p, 1 - p))
        successes <- which(success_vec == 1)
        if (length(successes) == 0) {
          return(list(label = "No successes", probability = prob, ev1 = 0, segments = data.frame()))
        }
        end_time <- min(expiry[successes])
        active_releases <- release[successes]
        eligible <- active_releases <= end_time
        successes <- successes[eligible]
        if (length(successes) == 0) {
          return(list(label = "No window", probability = prob, ev1 = 0, segments = data.frame()))
        }
        end_time <- min(expiry[successes])
        times <- sort(unique(c(active_releases[eligible], end_time)))
        segments <- data.frame(company = integer(), start = as.Date(character()), end = as.Date(character()), share = double())
        ev1 <- 0
        for (i in seq_len(length(times) - 1)) {
          start <- times[i]
          stop <- times[i + 1]
          if (start >= end_time) next
          active <- successes[release[successes] <= start]
          if (length(active) == 0) next
          share <- 1 / length(active)
          dur <- as.numeric(difftime(stop, start, units = "days"))
          for (comp in active) {
            segments <- rbind(segments, data.frame(company = comp, start = start, end = stop, share = share))
            if (comp == 1) ev1 <- ev1 + share * dur
          }
        }
        label <- paste(c("A", "B", "C")[successes], collapse = "+")
        list(label = label, probability = prob, ev1 = ev1, segments = segments)
      }

      compute_scenarios <- function(p, release, expiry) {
        combos <- expand.grid(A = c(0, 1), B = c(0, 1), C = c(0, 1))
        scenario_list <- list()
        total_ev <- 0
        for (i in seq_len(nrow(combos))) {
          success_vec <- as.integer(unlist(combos[i, ]))
          scenario <- calc_scenario(success_vec, p, release, expiry)
          scenario$probability <- scenario$probability
          total_ev <- total_ev + scenario$probability * scenario$ev1
          scenario_list[[length(scenario_list) + 1]] <- scenario
        }
        list(expected_ev = total_ev, scenarios = scenario_list)
      }

      beta_params_from_mean_var <- function(m, v) {
        m <- pmin(pmax(m, 1e-6), 1 - 1e-6)
        max_var <- m * (1 - m)
        adj_v <- ifelse(v >= max_var, max_var * 0.999, v)
        t <- m * (1 - m) / adj_v - 1
        alpha <- m * t
        beta <- (1 - m) * t
        list(alpha = alpha, beta = beta, variance = adj_v, mean = m)
      }

      simulate_ev <- function(p_mean, v, release, expiry, n = 300) {
        ab <- beta_params_from_mean_var(p_mean, v)
        evs <- numeric(n)
        for (i in seq_len(n)) {
          p <- stats::rbeta(length(p_mean), ab$alpha, ab$beta)
          payload <- compute_scenarios(p, release, expiry)
          evs[i] <- payload$expected_ev
        }
        ci <- as.numeric(stats::quantile(evs, c(0.025, 0.975)))
        list(alpha = ab$alpha, beta = ab$beta, variance = ab$variance, mean = ab$mean, ci = ci, ev_samples = evs)
      }

      serialize_payload <- function(payload) {
        scenarios <- lapply(payload$scenarios, function(sc) {
          segments <- list()
          if (nrow(sc$segments) > 0) {
            segments <- lapply(seq_len(nrow(sc$segments)), function(i) {
              list(
                company = sc$segments$company[i],
                start = as.character(sc$segments$start[i]),
                end = as.character(sc$segments$end[i]),
                share = sc$segments$share[i]
              )
            })
          }
          list(
            label = sc$label,
            probability = sc$probability,
            ev1 = sc$ev1,
            segments = segments
          )
        })
        list(
          expected_ev = payload$expected_ev,
          expected_years = payload$expected_ev / 365,
          scenarios = scenarios,
          alpha = payload$alpha,
          beta = payload$beta,
          variance = payload$variance,
          mean = payload$mean,
          ci = payload$ci,
          ev_samples = payload$ev_samples
        )
      }

      plot_scenarios <- function(payload) {
        scenarios <- payload$scenarios
        valid <- Filter(function(x) nrow(x$segments) > 0, scenarios)
        if (length(valid) == 0) {
          plot.new()
          text(0.5, 0.5, "No market activity", cex = 1.2)
          return(invisible(NULL))
        }
        cols <- c("#5f4b8b", "#3c9d9b", "#e67300")
        n <- length(valid)
        rows <- ceiling(n / 2)
        par(mfrow = c(rows, 2), mar = c(3.1, 3.4, 2.4, 1.2), mgp = c(1.9, 0.6, 0))
        for (sc in valid) {
          segs <- sc$segments
          xlim <- range(c(segs$start, segs$end))
          plot(xlim, c(0, 1), type = "n", xlab = "Date", ylab = "Share", main = paste0(sc$label, " (p=", sprintf("%.2f", sc$probability), ")"))
          abline(h = 0, col = "#e5e7eb40")
          for (comp in 1:3) {
            segc <- segs[segs$company == comp, ]
            if (nrow(segc) == 0) next
            for (j in seq_len(nrow(segc))) {
              lines(x = c(segc$start[j], segc$end[j]), y = c(segc$share[j], segc$share[j]), col = cols[comp], lwd = 3)
            }
          }
        }
      }
    `;

    const initWebR = async () => {
      setStatus('Starting WebR…');
      await webR.init();
      await webR.evalRVoid(bootstrapR);
      webRReady = true;
      runBtn.disabled = false;
      setStatus('Ready');
    };

    const buildCombinedCanvas = (scenarios, releases, expiries) => {
      const valid = scenarios.filter(sc => sc.segments && sc.segments.length > 0);
      const colors = ['#5f4b8b', '#3c9d9b', '#e67300'];
      const colCount = 2;
      const perHeight = 170;
      const rows = Math.max(1, Math.ceil(valid.length / colCount));
      const width = 900;
      const height = rows * perHeight;
      const canvas = document.createElement('canvas');
      const dpr = window.devicePixelRatio || 1;
      canvas.width = width * dpr;
      canvas.height = height * dpr;
      canvas.style.width = `${width}px`;
      canvas.style.height = `${height}px`;
      const ctx = canvas.getContext('2d');
      ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
      ctx.fillStyle = 'rgba(12,16,30,0.95)';
      ctx.fillRect(0, 0, width, height);

      const padX = 60;
      const padTop = 28;
      const padBottom = 32;
      const toMs = (d) => new Date(d).getTime();

      valid.forEach((sc, idx) => {
        const col = idx % colCount;
        const row = Math.floor(idx / colCount);
        const originX = col * (width / colCount);
        const originY = row * perHeight;
        const plotW = width / colCount;
        const plotStartX = originX + padX;
        const plotEndX = originX + plotW - padX;
        const yZero = originY + perHeight - padBottom;
        const yRange = perHeight - padTop - padBottom;

        const times = Array.from(new Set(sc.segments.flatMap(seg => [seg.start, seg.end]))).sort((a, b) => toMs(a) - toMs(b));
        if (times.length === 0) return;
        const timesMs = times.map(toMs);
        const minTime = Math.min(...timesMs);
        const maxTime = Math.max(...timesMs);
        const timeToX = (ms) => {
          if (maxTime === minTime) return (plotStartX + plotEndX) / 2;
          const t = (ms - minTime) / (maxTime - minTime);
          return plotStartX + t * (plotEndX - plotStartX);
        };

        const segsByCompany = [[], [], []];
        sc.segments.forEach(seg => {
          const idx = (seg.company ?? 1) - 1;
          if (!segsByCompany[idx]) segsByCompany[idx] = [];
          segsByCompany[idx].push(seg);
        });

        const lines = [[], [], []];
        const cumSeries = [[], [], []];
        const shareSeries = [[], [], []];
        const cum = [0, 0, 0];

        const findShare = (compIdx, tStart, tEnd) => {
          const segs = segsByCompany[compIdx] || [];
          for (const seg of segs) {
            if (toMs(seg.start) <= toMs(tStart) && toMs(seg.end) >= toMs(tEnd)) return seg.share;
          }
          return 0;
        };

        [0, 1, 2].forEach(ci => cumSeries[ci].push(0));
        for (let i = 1; i < times.length; i++) {
          const prev = times[i - 1];
          const cur = times[i];
          const durDays = (toMs(cur) - toMs(prev)) / 86400000;
          [0, 1, 2].forEach(ci => {
            const share = findShare(ci, prev, cur);
            shareSeries[ci].push(share);
            cum[ci] += share * durDays;
            cumSeries[ci].push(cum[ci]);
          });
        }

        const totalFinal = (cumSeries[0].at(-1) || 0) + (cumSeries[1].at(-1) || 0) + (cumSeries[2].at(-1) || 0);

        times.forEach((tStr, i) => {
          const total = totalFinal || 1;
          [0, 1, 2].forEach(ci => {
            const pct = total > 0 ? Math.min(100, (cumSeries[ci][i] / total) * 100) : 0;
            lines[ci].push({ x: timeToX(toMs(tStr)), y: yZero - (pct / 100) * yRange });
          });
        });

        ctx.fillStyle = '#e5e7eb';
        ctx.font = '12px Space Grotesk, sans-serif';
        ctx.fillText(`${sc.label} (p=${(sc.probability * 100).toFixed(1)}%)`, originX + 10, originY + 16);
        ctx.strokeStyle = '#ffffff25';
        ctx.lineWidth = 1;
        ctx.beginPath();
        ctx.moveTo(plotStartX, yZero);
        ctx.lineTo(plotEndX, yZero);
        ctx.stroke();

        [0, 1, 2].forEach(ci => {
          const pts = lines[ci];
          if (!pts || pts.length === 0) return;
          ctx.strokeStyle = colors[ci];
          ctx.lineWidth = 3;
          ctx.beginPath();
          ctx.moveTo(pts[0].x, pts[0].y);
          pts.slice(1).forEach(p => ctx.lineTo(p.x, p.y));
          ctx.stroke();
        });

        ctx.fillStyle = '#94a3b8';
        ctx.fillText('0%', originX + 12, yZero + 12);
        ctx.fillText('100%', originX + 12, originY + padTop + 4);
        const minDateStr = new Date(minTime).toISOString().slice(0, 10);
        const maxDateStr = new Date(maxTime).toISOString().slice(0, 10);
        ctx.fillText(minDateStr, plotStartX - 6, yZero + 16);
        ctx.fillText(maxDateStr, plotEndX - 40, yZero + 16);
      });

      return canvas;
    };

    const readInputs = () => {
      const cards = Array.from(document.querySelectorAll('.card[data-company]'));
      const probs = [];
      const releases = [];
      const expiries = [];
      const cvs = [];
      for (const card of cards) {
        const probEl = card.querySelector('[data-field="prob"]');
        const relEl = card.querySelector('[data-field="release"]');
        const expEl = card.querySelector('[data-field="expiry"]');
        const confEl = card.querySelector('[data-field="confidence"]');
        if (!probEl || !relEl || !expEl || !confEl) {
          throw new Error('Missing input elements for company card');
        }
        const prob = parseFloat(probEl.value);
        const rel = relEl.value;
        const exp = expEl.value;
        const conf = confEl.value;
        let cv;
        if (conf === 'high') cv = 0.01;
        else if (conf === 'medium') cv = 0.05;
        else if (conf === 'low') cv = 0.2;
        else cv = 0.05;
        probs.push(prob);
        releases.push(rel);
        expiries.push(exp);
        cvs.push(cv);
      }
      return { probs, releases, expiries, cvs };
    };

      const renderScenarios = (scenarios, maxShareDays) => {
        scenarioList.innerHTML = '';
        const norm = maxShareDays > 0 ? maxShareDays : 1;
        scenarios.forEach((sc) => {
          const card = document.createElement('div');
        card.className = 'scenario-card';
        const prob = (sc.probability * 100).toFixed(1);
        const pct = ((sc.ev1 / norm) * 100).toFixed(1);
        card.innerHTML = `
          <h4>${sc.label}</h4>
          <div class="meta">Probability: ${prob}% · Company A share: ${pct}% of max</div>
        `;
        scenarioList.appendChild(card);
      });
    };

    const renderSimulationPlot = (evSamples, maxShareDays, pathSamples, releases, expiries) => {
      const canvas = simPlotEl;
      const ctx = canvas.getContext('2d');
      const width = canvas.clientWidth || 900;
      const height = 320;
      const dpr = window.devicePixelRatio || 1;
      canvas.width = width * dpr;
      canvas.height = height * dpr;
      canvas.style.height = `${height}px`;
      ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
      ctx.clearRect(0, 0, width, height);
      ctx.fillStyle = '#0c1020';
      ctx.fillRect(0, 0, width, height);

        const normalizePath = (p) => {
          if (!p) return [];
          if (Array.isArray(p)) {
            if (p.length > 0 && typeof p[0] === 'object' && 'company' in p[0]) return p;
            return p;
          }
          if (typeof p === 'object') {
            if (p.company && p.start && p.end && p.share) {
              const len = Math.min(p.company.length || 0, p.start.length || 0, p.end.length || 0, p.share.length || 0);
              return Array.from({ length: len }, (_, i) => ({
                company: p.company[i],
                start: p.start[i],
                end: p.end[i],
                share: p.share[i],
                weight: p.weight ? p.weight[i] : undefined
              }));
            }
            if (p.start && p.end && p.share && Array.isArray(p.start)) {
              const len = Math.min(p.start.length, p.end.length, p.share.length);
              return Array.from({ length: len }, (_, i) => ({
                company: p.company && p.company[i] ? p.company[i] : 1,
                start: p.start[i],
                end: p.end[i],
                share: p.share[i],
                weight: p.weight ? p.weight[i] : undefined
              }));
            }
          }
          return [];
        };

      console.log('renderSimulationPlot: raw pathSamples', pathSamples);
      const normalizedPaths = [];
      (pathSamples || []).forEach(p => {
        const n = normalizePath(p);
        if (n.length > 0) normalizedPaths.push(n);
      });
      console.log('renderSimulationPlot: normalizedPaths length', normalizedPaths.length);

      if (normalizedPaths.length === 0) {
        ctx.fillStyle = '#e5e7eb';
        ctx.fillText('No simulation path data', 12, 20);
        return;
      }

      const colors = ['#5f4b8b', '#3c9d9b', '#e67300'];
      const padX = 60;
      const padTop = 32;
      const padBottom = 40;
      const yZero = height - padBottom;
      const yRange = height - padTop - padBottom;
      const toMs = (d) => {
        if (d === null || d === undefined) return null;
        if (typeof d === 'number') {
          const days = d;
          const ms = days * 86400000;
          if (Number.isFinite(ms)) return ms;
        }
        const t = new Date(d).getTime();
        if (Number.isFinite(t)) return t;
        const asNum = Number(d);
        if (Number.isFinite(asNum)) {
          const ms2 = asNum * 86400000;
          if (Number.isFinite(ms2)) return ms2;
        }
        console.warn('Invalid date encountered in spaghetti plot', d);
        return null;
      };

      // Determine global time range from releases/expiries or paths
      const allDates = [];
      releases.forEach(d => d && allDates.push(toMs(d)));
      expiries.forEach(d => d && allDates.push(toMs(d)));
      const pathTimes = [];
      normalizedPaths.forEach(path => {
        path.forEach(seg => {
          const s = toMs(seg.start);
          const e = toMs(seg.end);
          if (s !== null) pathTimes.push(s);
          if (e !== null) pathTimes.push(e);
        });
      });
      const validDates = allDates.filter(t => t !== null);
      const minTime = Math.min(...pathTimes, ...validDates);
      const maxTime = Math.max(...pathTimes, ...validDates);
      console.log('spaghetti timing', { minTime, maxTime, pathTimes, validDates });
      if (!Number.isFinite(minTime) || !Number.isFinite(maxTime) || minTime === maxTime) {
        ctx.fillStyle = '#e5e7eb';
        ctx.fillText('Insufficient time data for spaghetti plot', 12, 20);
        return;
      }
      const timeToX = (ms) => {
        if (maxTime === minTime) return width / 2;
        const t = (ms - minTime) / (maxTime - minTime);
        return padX + t * (width - 2 * padX);
      };

      const maxWeight = Math.max(...normalizedPaths.map(p => p[0]?.weight || 0), 1e-6);

      const buildLines = (path) => {
        const times = Array.from(new Set(path.flatMap(seg => [seg.start, seg.end].map(toMs).filter(t => t !== null)))).sort((a, b) => a - b);
        if (times.length < 2) return null;
        const segsByCompany = [[], [], []];
        path.forEach(seg => {
          const idx = (seg.company ?? 1) - 1;
          if (!segsByCompany[idx]) segsByCompany[idx] = [];
          segsByCompany[idx].push(seg);
        });
        const cumSeries = [[], [], []];
        const cum = [0, 0, 0];
        [0, 1, 2].forEach(ci => cumSeries[ci].push(0));
        for (let i = 1; i < times.length; i++) {
          const prev = times[i - 1];
          const cur = times[i];
          const durDays = (cur - prev) / 86400000;
          [0, 1, 2].forEach(ci => {
            const segs = segsByCompany[ci] || [];
            const share = segs.find(s => toMs(s.start) <= prev && toMs(s.end) >= cur)?.share || 0;
            cum[ci] += share * durDays;
            cumSeries[ci].push(cum[ci]);
          });
        }
        const totalFinal = (cumSeries[0].at(-1) || 0) + (cumSeries[1].at(-1) || 0) + (cumSeries[2].at(-1) || 0) || 1;
        const lines = [[], [], []];
        times.forEach((t, idx) => {
          [0, 1, 2].forEach(ci => {
            const pct = Math.min(100, (cumSeries[ci][idx] / totalFinal) * 100);
            lines[ci].push({ x: timeToX(t), y: yZero - (pct / 100) * yRange });
          });
        });
        return lines;
      };

      normalizedPaths.forEach(path => {
        const alpha = Math.min(0.5, Math.max(0.05, (path[0].weight || 0) / maxWeight * 0.5));
        const lines = buildLines(path);
        if (!lines) return;
        ctx.globalAlpha = alpha;
        [0, 1, 2].forEach(ci => {
          const pts = lines[ci];
          if (!pts || pts.length === 0) return;
          ctx.strokeStyle = colors[ci];
          ctx.lineWidth = 2;
          ctx.beginPath();
          ctx.moveTo(pts[0].x, pts[0].y);
          pts.slice(1).forEach(p => ctx.lineTo(p.x, p.y));
          ctx.stroke();
        });
      });
      ctx.globalAlpha = 1;
      ctx.globalAlpha = 1;

      ctx.fillStyle = '#94a3b8';
      ctx.font = '12px Space Grotesk, sans-serif';
      ctx.fillText('0%', 12, yZero + 12);
      ctx.fillText('100%', 12, padTop + 4);
      ctx.fillText(new Date(minTime).toISOString().slice(0, 10), padX - 6, yZero + 18);
      ctx.fillText(new Date(maxTime).toISOString().slice(0, 10), width - padX - 80, yZero + 18);
    };

    const renderPlot = (scenarios, releases, expiries) => {
      const canvas = plotEl;
      const ctx = canvas.getContext('2d');
      const valid = scenarios.filter(sc => sc.segments && sc.segments.length > 0);
      const colors = ['#5f4b8b', '#3c9d9b', '#e67300'];
      const colCount = 2;
      const perHeight = 150;
      const rows = Math.max(1, Math.ceil(valid.length / colCount));
      const width = canvas.clientWidth || canvas.parentElement.clientWidth || 920;
      const height = rows * perHeight;
      const dpr = window.devicePixelRatio || 1;
      canvas.width = width * dpr;
      canvas.height = height * dpr;
      canvas.style.height = `${height}px`;
      ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
      ctx.clearRect(0, 0, width, height);
      ctx.font = '12px Space Grotesk, sans-serif';
      ctx.fillStyle = '#e5e7eb';

      if (valid.length === 0) {
        ctx.fillText('No market activity to plot', 12, 24);
        return;
      }

      const toMs = (d) => new Date(d).getTime();
      const allStarts = valid.flatMap(sc => sc.segments.map(seg => toMs(seg.start)));
      const allEnds = valid.flatMap(sc => sc.segments.map(seg => toMs(seg.end)));
      const minTime = Math.min(...allStarts);
      const maxTime = Math.max(...allEnds);

      const plotW = width / colCount;
      const padX = 60;
      const padTop = 28;
      const padBottom = 30;
      const yZero = perHeight - padBottom;
      const yRange = perHeight - padTop - padBottom;

      // Precompute best-case share-days per company for normalization.
      const maxShareDays = [0, 0, 0].map((_, i) => {
        if (!releases[i] || !expiries[i]) return 0;
        const span = (new Date(expiries[i]).getTime() - new Date(releases[i]).getTime()) / 86400000;
        return Math.max(0, span);
      });

      const plotsState = [];

      valid.forEach((sc, idx) => {
        const col = idx % colCount;
        const row = Math.floor(idx / colCount);
        const originX = col * plotW;
        const originY = row * perHeight;
        const plotStartX = originX + padX;
        const plotEndX = originX + plotW - padX;

        const timeToX = (ms) => {
          if (maxTime === minTime) return (plotStartX + plotEndX) / 2;
          const t = (ms - minTime) / (maxTime - minTime);
          return plotStartX + t * (plotEndX - plotStartX);
        };

        // Title
        ctx.fillStyle = '#e5e7eb';
        ctx.fillText(`${sc.label} (p=${(sc.probability * 100).toFixed(1)}%)`, originX + 10, originY + 16);

        // Axis
        ctx.strokeStyle = '#ffffff25';
        ctx.lineWidth = 1;
        ctx.beginPath();
        ctx.moveTo(plotStartX, originY + yZero);
        ctx.lineTo(plotEndX, originY + yZero);
        ctx.stroke();

        // Build per-company cumulative percent lines.
        const times = Array.from(new Set(sc.segments.flatMap(seg => [seg.start, seg.end]))).sort((a, b) => toMs(a) - toMs(b));
        const timesMs = times.map(toMs);
        const segsByCompany = [[], [], []];
        sc.segments.forEach(seg => {
          const idx = (seg.company ?? 1) - 1;
          if (!segsByCompany[idx]) segsByCompany[idx] = [];
          segsByCompany[idx].push(seg);
        });

        const lines = [[], [], []];
        const cumSeries = [[], [], []];
        const shareSeries = [[], [], []];
        const cum = [0, 0, 0];

        const findShare = (compIdx, tStart, tEnd) => {
          const segs = segsByCompany[compIdx] || [];
          for (const seg of segs) {
            if (toMs(seg.start) <= toMs(tStart) && toMs(seg.end) >= toMs(tEnd)) {
              return seg.share;
            }
          }
          return 0;
        };

        // Seed with time 0 cumulative
        [0, 1, 2].forEach(ci => {
          cumSeries[ci].push(0);
        });

        for (let i = 1; i < times.length; i++) {
          const prev = times[i - 1];
          const cur = times[i];
          const durDays = (toMs(cur) - toMs(prev)) / 86400000;
          [0, 1, 2].forEach(ci => {
            const share = findShare(ci, prev, cur);
            shareSeries[ci].push(share);
            cum[ci] += share * durDays;
            cumSeries[ci].push(cum[ci]);
          });
        }

        // Points for drawing lines
        const totalSeries = times.map((_, i) => (cumSeries[0][i] || 0) + (cumSeries[1][i] || 0) + (cumSeries[2][i] || 0));
        const totalFinal = totalSeries[totalSeries.length - 1] || 0;
        times.forEach((tStr, i) => {
          const total = totalFinal;
          [0, 1, 2].forEach(ci => {
            const pct = total > 0 ? Math.min(100, (cumSeries[ci][i] / total) * 100) : 0;
            lines[ci].push({ x: timeToX(toMs(tStr)), y: originY + yZero - (pct / 100) * yRange });
          });
        });

        // Draw lines per company
        [0, 1, 2].forEach(ci => {
          const pts = lines[ci];
          if (!pts || pts.length === 0) return;
          ctx.strokeStyle = colors[ci];
          ctx.lineWidth = 3;
          ctx.beginPath();
          ctx.moveTo(pts[0].x, pts[0].y);
          pts.slice(1).forEach(p => ctx.lineTo(p.x, p.y));
          ctx.stroke();
        });

        // Y-axis labels
        ctx.fillStyle = '#94a3b8';
        ctx.fillText('0%', originX + 12, originY + yZero + 12);
        ctx.fillText('100%', originX + 12, originY + padTop + 4);

        // Ticks (start/end)
        ctx.fillStyle = '#94a3b8';
        const minDateStr = new Date(minTime).toISOString().slice(0, 10);
        const maxDateStr = new Date(maxTime).toISOString().slice(0, 10);
        ctx.fillText(minDateStr, plotStartX - 6, originY + yZero + 16);
        ctx.fillText(maxDateStr, plotEndX - 40, originY + yZero + 16);

        plotsState.push({
          originX,
          originY,
          plotStartX,
          plotEndX,
          width: plotW,
          height: perHeight,
          minTime,
          maxTime,
          timesMs,
          cumSeries,
          shareSeries,
          totalSeries,
          totalFinal,
          label: sc.label
        });
      });

      plotState = {
        plots: plotsState,
        padTop,
        padBottom,
        colors
      };
    };

    const runModel = async () => {
      if (!webRReady) {
        setStatus('WebR still loading…');
        return;
      }
      const { probs, releases, expiries, cvs } = readInputs();
      const maxShareDays = Math.max(0, (new Date(expiries[0]).getTime() - new Date(releases[0]).getTime()) / 86400000);
      if (probs.some(p => isNaN(p) || p < 0 || p > 1)) {
        setStatus('Probabilities must be between 0 and 1.');
        return;
      }
      if (cvs.some(c => isNaN(c) || c <= 0)) {
        setStatus('Confidence CV must be positive numbers.');
        return;
      }
      if (releases.some(d => !d) || expiries.some(d => !d)) {
        setStatus('Please provide all dates.');
        return;
      }
      setStatus('Running in WebR…');
      runBtn.disabled = true;

      const rCode = `
        p <- c(${probs.join(",")})
        cv <- c(${cvs.join(",")})
        release <- as.Date(c(${releases.map(d => `"${d}"`).join(",")}))
        expiry <- as.Date(c(${expiries.map(d => `"${d}"`).join(",")}))
        var_vec <- (cv * p) ^ 2
        base_payload <- compute_scenarios(p, release, expiry)
        sim <- simulate_ev(p, var_vec, release, expiry)
        combined <- c(base_payload, sim)
        serialize_payload(combined)
      `;

      const simplify = (node) => {
        if (node === null || node === undefined) return null;
        if (Array.isArray(node)) return node.map(simplify);
        if (typeof node === 'object' && 'type' in node && 'values' in node) {
          const { type, values, names } = node;
          if (type === 'double' || type === 'integer') {
            return values.length === 1 ? values[0] : values;
          }
          if (type === 'logical') {
            return values.length === 1 ? !!values[0] : values.map(Boolean);
          }
          if (type === 'character') {
            return values.length === 1 ? values[0] : values;
          }
          if (type === 'dataframe' && node.names && Array.isArray(values)) {
            const cols = node.names;
            const colData = values.map(simplify);
            const len = Math.min(...colData.map(c => (Array.isArray(c) ? c.length : 0)));
            const rows = [];
            for (let i = 0; i < len; i++) {
              const row = {};
              cols.forEach((col, idx) => {
                if (Array.isArray(colData[idx])) row[col] = colData[idx][i];
              });
              rows.push(row);
            }
            return rows;
          }
          if (type === 'list') {
            const mapped = values.map(simplify);
            if (names && names.length === values.length && names.some(Boolean)) {
              const obj = {};
              mapped.forEach((val, i) => {
                const key = names[i] || i;
                obj[key] = val;
              });
              return obj;
            }
            return mapped;
          }
        }
        if (typeof node === 'object') {
          const obj = {};
          for (const [k, v] of Object.entries(node)) obj[k] = simplify(v);
          return obj;
        }
        return node;
      };

      let jsData = null;
      try {
        const payload = await webR.evalR(rCode);
        const jsRaw = await payload.toJs();
        jsData = simplify(jsRaw);
      } catch (err) {
        console.error('WebR eval error', err);
        setStatus('Error running R code; see console.');
        runBtn.disabled = false;
        return;
      }

      if (!jsData || typeof jsData.expected_ev !== 'number') {
        console.error('Unexpected payload from WebR', jsData);
        setStatus('Unexpected result from R; see console.');
        runBtn.disabled = false;
        return;
      }

      const evPct = maxShareDays > 0 ? (jsData.expected_ev / maxShareDays) * 100 : 0;
      const ciLower = jsData.ci && jsData.ci[0] ? jsData.ci[0] : null;
      const ciUpper = jsData.ci && jsData.ci[1] ? jsData.ci[1] : null;
      const ciPctLower = ciLower !== null && maxShareDays > 0 ? (ciLower / maxShareDays) * 100 : null;
      const ciPctUpper = ciUpper !== null && maxShareDays > 0 ? (ciUpper / maxShareDays) * 100 : null;
      const ciText = ciPctLower !== null && ciPctUpper !== null
        ? ` (95% CI: ${ciPctLower.toFixed(1)}%–${ciPctUpper.toFixed(1)}%)`
        : '';
      evEl.textContent = `${evPct.toFixed(1)}% of max (max=${maxShareDays.toFixed(1)} share-days)${ciText}`;
      renderScenarios(jsData.scenarios, maxShareDays);

      try {
        renderPlot(jsData.scenarios, releases, expiries);
      } catch (err) {
        console.error('Plot render failed', err);
        setStatus('EV computed; plot render failed (see console).');
        runBtn.disabled = false;
        return;
      }

      setStatus('Updated');
      runBtn.disabled = false;
      downloadBtn.disabled = false;
      lastResults = jsData;
      lastInputs = { probs, releases, expiries, maxShareDays, cvs };
    };

    const handleHover = (event) => {
      if (!plotState || !plotState.plots) return;
      const rect = plotEl.getBoundingClientRect();
      const x = event.clientX - rect.left;
      const y = event.clientY - rect.top;
      const plot = plotState.plots.find(p =>
        x >= p.originX && x <= p.originX + p.width &&
        y >= p.originY && y <= p.originY + p.height
      );
      if (!plot) {
        tooltip.style.opacity = 0;
        return;
      }
      const { plotStartX, plotEndX, minTime, maxTime, timesMs, cumSeries, shareSeries, totalSeries, totalFinal, label } = plot;
      const tRatio = Math.max(0, Math.min(1, (x - plotStartX) / (plotEndX - plotStartX)));
      const timeMs = minTime + tRatio * (maxTime - minTime);

      const getPct = (ci) => {
        const times = timesMs;
        const cum = cumSeries[ci] || [];
        const shares = shareSeries[ci] || [];
        const totals = totalSeries || [];
        const totalTarget = totalFinal || (totals.length ? totals[totals.length - 1] : 0);
        if (!times || times.length === 0) return 0;
        let idx = times.findIndex(t => timeMs < t);
        if (idx === -1) idx = times.length;
        if (idx === 0) return 0;
        const startMs = times[idx - 1];
        const endMs = times[idx] ?? times[idx - 1];
        const spanMs = Math.max(1, endMs - startMs);
        const deltaDays = (timeMs - startMs) / 86400000;
        const baseCum = cum[idx - 1] ?? 0;
        const share = shares[idx - 1] ?? 0;
        const totalPrev = totals[idx - 1] ?? 0;
        const totalNext = totals[idx] ?? totals[totals.length - 1] ?? totalPrev;
        const frac = Math.max(0, Math.min(1, (timeMs - startMs) / spanMs));
        const total = Math.max(0.000001, totalTarget); // normalize to final total only
        const pct = ((baseCum + share * deltaDays) / total) * 100;
        return Math.max(0, Math.min(100, pct));
      };

      const dateStr = new Date(timeMs).toISOString().slice(0, 10);
      const lines = [0, 1, 2].map(ci => ({
        name: ['A', 'B', 'C'][ci],
        pct: getPct(ci)
      }));

      tooltip.innerHTML = `
        <div style="font-weight:700;margin-bottom:4px;">${label}</div>
        <div style="color:#94a3b8;">Date: ${dateStr}</div>
        ${lines.map(l => `<div><span style="display:inline-block;width:10px;height:10px;border-radius:50%;background:${plotState.colors[l.name === 'A' ? 0 : l.name === 'B' ? 1 : 2]};margin-right:6px;"></span>${l.name}: ${l.pct.toFixed(1)}%</div>`).join('')}
      `;
      tooltip.style.left = `${event.clientX + 12}px`;
      tooltip.style.top = `${event.clientY + 12}px`;
      tooltip.style.opacity = 1;
    };

    plotEl.addEventListener('mousemove', handleHover);
    plotEl.addEventListener('mouseleave', () => { tooltip.style.opacity = 0; });
    downloadBtn.addEventListener('click', async () => {
      if (!lastResults || !lastInputs) {
        setStatus('Run the model first.');
        return;
      }
      downloadBtn.disabled = true;
      setStatus('Preparing ZIP…');
      const zip = new JSZip();

      // CSV: inputs + scenarios
      const { probs, releases, expiries, maxShareDays, cvs } = lastInputs;
      const lines = [];
      lines.push('Inputs');
      lines.push('Company,SuccessProbability,CoefficientOfVariation,ReleaseDate,ExpiryDate');
      ['A','B','C'].forEach((c,i)=>{
        lines.push(`${c},${probs[i]},${cvs[i]},${releases[i]},${expiries[i]}`);
      });
      lines.push('');
      lines.push(`ExpectedEVShareDays,${lastResults.expected_ev}`);
      const evPct = maxShareDays > 0 ? (lastResults.expected_ev / maxShareDays) * 100 : 0;
      lines.push(`ExpectedEVPercentOfMax,${evPct}`);
      if (lastResults.ci && lastResults.ci.length === 2) {
        const ciPctLower = maxShareDays > 0 ? (lastResults.ci[0] / maxShareDays) * 100 : '';
        const ciPctUpper = maxShareDays > 0 ? (lastResults.ci[1] / maxShareDays) * 100 : '';
        lines.push(`CI95_Lower,${lastResults.ci[0]}`);
        lines.push(`CI95_Upper,${lastResults.ci[1]}`);
        lines.push(`CI95_LowerPercentOfMax,${ciPctLower}`);
        lines.push(`CI95_UpperPercentOfMax,${ciPctUpper}`);
      }
      lines.push('');
      lines.push('Scenarios');
      lines.push('Label,Probability,EV_ShareDays');
      lastResults.scenarios.forEach(sc=>{
        lines.push(`${sc.label},${sc.probability},${sc.ev1}`);
      });
      zip.file('results.csv', lines.join('\n'));

      // Graphs: one PNG per scenario with segments
      const colors = ['#5f4b8b', '#3c9d9b', '#e67300'];
      const toMs = (d) => new Date(d).getTime();

      const drawScenarioCanvas = (sc) => {
        const canvas = document.createElement('canvas');
        const width = 900;
        const height = 220;
        const dpr = window.devicePixelRatio || 1;
        canvas.width = width * dpr;
        canvas.height = height * dpr;
        canvas.style.width = `${width}px`;
        canvas.style.height = `${height}px`;
        const ctx = canvas.getContext('2d');
        ctx.setTransform(dpr,0,0,dpr,0,0);
        ctx.fillStyle = 'rgba(12,16,30,0.95)';
        ctx.fillRect(0,0,width,height);
        ctx.strokeStyle = '#ffffff20';
        ctx.lineWidth = 1;

        if (!sc.segments || sc.segments.length === 0) {
          ctx.fillStyle = '#e5e7eb';
          ctx.fillText('No market activity', 12, 20);
          return canvas;
        }

        const times = Array.from(new Set(sc.segments.flatMap(seg => [seg.start, seg.end]))).sort((a,b)=>toMs(a)-toMs(b));
        const timesMs = times.map(toMs);
        const segsByCompany = [[],[],[]];
        sc.segments.forEach(seg=>{
          const idx = (seg.company ?? 1) -1;
          if (!segsByCompany[idx]) segsByCompany[idx]=[];
          segsByCompany[idx].push(seg);
        });

        const linesLocal = [[],[],[]];
        const cumSeries = [[],[],[]];
        const shareSeries = [[],[],[]];
        const cum = [0,0,0];

        const findShare = (compIdx, tStart, tEnd) => {
          const segs = segsByCompany[compIdx] || [];
          for (const seg of segs) {
            if (toMs(seg.start) <= toMs(tStart) && toMs(seg.end) >= toMs(tEnd)) return seg.share;
          }
          return 0;
        };

        [0,1,2].forEach(ci=>cumSeries[ci].push(0));
        for(let i=1;i<times.length;i++){
          const prev=times[i-1], cur=times[i];
          const durDays=(toMs(cur)-toMs(prev))/86400000;
          [0,1,2].forEach(ci=>{
            const share=findShare(ci, prev, cur);
            shareSeries[ci].push(share);
            cum[ci]+=share*durDays;
            cumSeries[ci].push(cum[ci]);
          });
        }

        const totalFinal = (cumSeries[0].at(-1)||0)+(cumSeries[1].at(-1)||0)+(cumSeries[2].at(-1)||0);
        const padX=60, padTop=28, padBottom=32;
        const plotStartX=padX, plotEndX=width-padX;
        const yZero=height-padBottom, yRange=height-padTop-padBottom;
        const minTime=Math.min(...timesMs), maxTime=Math.max(...timesMs);
        const timeToX=(ms)=> {
          if (maxTime===minTime) return (plotStartX+plotEndX)/2;
          const t=(ms-minTime)/(maxTime-minTime);
          return plotStartX + t*(plotEndX-plotStartX);
        };

        times.forEach((tStr,i)=>{
          const total=totalFinal||1;
          [0,1,2].forEach(ci=>{
            const pct= total>0 ? Math.min(100,(cumSeries[ci][i]/total)*100):0;
            linesLocal[ci].push({x: timeToX(toMs(tStr)), y: yZero - (pct/100)*yRange});
          });
        });

        ctx.fillStyle='#e5e7eb';
        ctx.fillText(`${sc.label} (p=${(sc.probability*100).toFixed(1)}%)`,12,18);
        ctx.strokeStyle='#ffffff25';
        ctx.beginPath(); ctx.moveTo(plotStartX,yZero); ctx.lineTo(plotEndX,yZero); ctx.stroke();

        [0,1,2].forEach(ci=>{
          const pts=linesLocal[ci];
          if (!pts || pts.length===0) return;
          ctx.strokeStyle=colors[ci];
          ctx.lineWidth=3;
          ctx.beginPath();
          ctx.moveTo(pts[0].x, pts[0].y);
          pts.slice(1).forEach(p=>ctx.lineTo(p.x,p.y));
          ctx.stroke();
        });

        ctx.fillStyle='#94a3b8';
        ctx.fillText('0%', 12, yZero+12);
        ctx.fillText('100%', 12, padTop+4);
        const minDateStr=new Date(minTime).toISOString().slice(0,10);
        const maxDateStr=new Date(maxTime).toISOString().slice(0,10);
        ctx.fillText(minDateStr, plotStartX-6, yZero+16);
        ctx.fillText(maxDateStr, plotEndX-40, yZero+16);

        return canvas;
      };

      const imgFolder = zip.folder('graphs');
      for (const sc of lastResults.scenarios) {
        if (!sc.segments || sc.segments.length === 0) continue;
        const canvas = drawScenarioCanvas(sc);
        const blob = await new Promise(res => canvas.toBlob(res, 'image/png'));
        if (blob) {
          const buf = await blob.arrayBuffer();
          imgFolder.file(`${sc.label || 'scenario'}.png`, buf);
        }
      }

      // Combined graph file
      const combinedCanvas = buildCombinedCanvas(lastResults.scenarios, releases, expiries);
      const combinedBlob = await new Promise(res => combinedCanvas.toBlob(res, 'image/png'));
      if (combinedBlob) {
        const buf = await combinedBlob.arrayBuffer();
        imgFolder.file('all-scenarios.png', buf);
      }

      const content = await zip.generateAsync({ type: 'blob' });
      const url = URL.createObjectURL(content);
      const a = document.createElement('a');
      a.href = url;
      a.download = 'pharma-results.zip';
      a.click();
      URL.revokeObjectURL(url);
      setStatus('ZIP downloaded');
      downloadBtn.disabled = false;
    });
    runBtn.addEventListener('click', runModel);
    initWebR();
  </script>
</body>
</html>
